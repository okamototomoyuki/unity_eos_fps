// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;
using System.Runtime.InteropServices;

namespace Epic.OnlineServices.Connect
{
	public sealed class ConnectInterface : Handle
	{
		public ConnectInterface() : base(IntPtr.Zero)
		{
		}

		public ConnectInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// Timestamp value representing an undefined time for last login time.
		/// </summary>
		public const int TimeUndefined = -1;

		/// <summary>
		/// Maximum number of account ids that can be queried at once
		/// </summary>
		public const int QueryexternalaccountmappingsMaxAccountIds = 128;

		/// <summary>
		/// Max length of a device model name, not including the terminating null
		/// </summary>
		public const int CreatedeviceidDevicemodelMaxLength = 64;

		/// <summary>
		/// Max length of a display name, not including the terminating null
		/// </summary>
		public const int UserlogininfoDisplaynameMaxLength = 32;

		/// <summary>
		/// Max length of an external account id in string form
		/// </summary>
		public const int ExternalAccountIdMaxLength = 256;

		/// <summary>
		/// Login/Authenticate given a valid set of external auth credentials.
		/// </summary>
		/// <param name="options">structure containing the external account credentials and type to use during the login operation</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the login operation completes, either successfully or in error</param>
		public void Login(LoginOptions options, object clientData, OnLoginCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<LoginOptionsInternal>(options);

			var completionDelegateInternal = new OnLoginCallbackInternal(OnLogin);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_Login(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Create an account association with the Epic Online Service as a product user given their external auth credentials
		/// </summary>
		/// <param name="options">structure containing a continuance token from a "user not found" response during Login (always try login first)</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the create operation completes, either successfully or in error</param>
		public void CreateUser(CreateUserOptions options, object clientData, OnCreateUserCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<CreateUserOptionsInternal>(options);

			var completionDelegateInternal = new OnCreateUserCallbackInternal(OnCreateUser);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_CreateUser(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Link a set of external auth credentials with an existing product user on the Epic Online Service
		/// </summary>
		/// <param name="options">structure containing a continuance token from a "user not found" response during Login (always try login first) and a currently logged in user not already associated with this external auth provider</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the link operation completes, either successfully or in error</param>
		public void LinkAccount(LinkAccountOptions options, object clientData, OnLinkAccountCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<LinkAccountOptionsInternal>(options);

			var completionDelegateInternal = new OnLinkAccountCallbackInternal(OnLinkAccount);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_LinkAccount(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Create a new unique pseudo-account that can be used to identify the current user profile on the local device.
		/// 
		/// This function is intended to be used by mobile games and PC games that wish to allow
		/// a new user to start playing without requiring to login to the game using any user identity.
		/// In addition to this, the Device ID feature is used to automatically login the local user
		/// also when they have linked at least one external user account(s) with the local Device ID.
		/// 
		/// It is possible to link many devices with the same user's account keyring using the Device ID feature.
		/// 
		/// Linking a device later or immediately with a real user account will ensure that the player
		/// will not lose their progress if they switch devices or lose the device at some point,
		/// as they will be always able to login with one of their linked real accounts and also link
		/// another new device with the user account associations keychain. Otherwise, without having
		/// at least one permanent user account linked to the Device ID, the player would lose all of their
		/// game data and progression permanently should something happen to their device or the local
		/// user profile on the device.
		/// 
		/// After a successful one-time CreateDeviceId operation, the game can login the local user
		/// automatically on subsequent game starts with <see cref="Login" /> using the <see cref="ExternalCredentialType.DeviceidAccessToken" />
		/// credentials type. If a Device ID already exists for the local user on the device then <see cref="Result.DuplicateNotAllowed" />
		/// error result is returned and the caller should proceed to calling <see cref="Login" /> directly.
		/// </summary>
		/// <param name="options">structure containing operation input parameters</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the create operation completes, either successfully or in error</param>
		public void CreateDeviceId(CreateDeviceIdOptions options, object clientData, OnCreateDeviceIdCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<CreateDeviceIdOptionsInternal>(options);

			var completionDelegateInternal = new OnCreateDeviceIdCallbackInternal(OnCreateDeviceId);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_CreateDeviceId(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Delete any existing Device ID access credentials for the current user profile on the local device.
		/// 
		/// The deletion is permanent and it is not possible to recover lost game data and progression
		/// if the Device ID had not been linked with at least one real external user account.
		/// </summary>
		/// <param name="options">structure containing operation input parameters</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the delete operation completes, either successfully or in error</param>
		public void DeleteDeviceId(DeleteDeviceIdOptions options, object clientData, OnDeleteDeviceIdCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<DeleteDeviceIdOptionsInternal>(options);

			var completionDelegateInternal = new OnDeleteDeviceIdCallbackInternal(OnDeleteDeviceId);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_DeleteDeviceId(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Retrieve the equivalent product user ids from a list of external account ids from supported account providers. The values will be cached and retrievable via <see cref="GetExternalAccountMapping" />
		/// </summary>
		/// <param name="options">structure containing a list of external account ids, in string form, to query for the product user id representation</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the query operation completes, either successfully or in error</param>
		public void QueryExternalAccountMappings(QueryExternalAccountMappingsOptions options, object clientData, OnQueryExternalAccountMappingsCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<QueryExternalAccountMappingsOptionsInternal>(options);

			var completionDelegateInternal = new OnQueryExternalAccountMappingsCallbackInternal(OnQueryExternalAccountMappings);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_QueryExternalAccountMappings(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Retrieve the equivalent external account mappings from a list of product user ids.
		/// This will include data for each external account info found for the linked product ids.
		/// 
		/// The values will be cached and retrievable via <see cref="GetProductUserIdMapping" />, <see cref="CopyProductUserExternalAccountByIndex" />,
		/// <see cref="CopyProductUserExternalAccountByAccountType" /> or <see cref="CopyProductUserExternalAccountByAccountId" />.
		/// <seealso cref="ExternalAccountInfo" />
		/// <seealso cref="GetProductUserExternalAccountCount" />
		/// <seealso cref="GetProductUserIdMapping" />
		/// <seealso cref="CopyProductUserExternalAccountByIndex" />
		/// <seealso cref="CopyProductUserExternalAccountByAccountType" />
		/// <seealso cref="CopyProductUserExternalAccountByAccountId" />
		/// <seealso cref="CopyProductUserInfo" />
		/// <seealso cref="Achievements" />
		/// </summary>
		/// <param name="options">structure containing a list of product user ids to query for the external account representation</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the query operation completes, either successfully or in error</param>
		public void QueryProductUserIdMappings(QueryProductUserIdMappingsOptions options, object clientData, OnQueryProductUserIdMappingsCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<QueryProductUserIdMappingsOptionsInternal>(options);

			var completionDelegateInternal = new OnQueryProductUserIdMappingsCallbackInternal(OnQueryProductUserIdMappings);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_QueryProductUserIdMappings(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Fetch a product user id that maps to an external account id
		/// </summary>
		/// <param name="options">structure containing the local user and target external account id</param>
		/// <returns>
		/// the product user id, previously retrieved from the backend service, for the given target external account
		/// </returns>
		public ProductUserId GetExternalAccountMapping(GetExternalAccountMappingsOptions options)
		{
			var optionsInternal = Helper.CopyProperties<GetExternalAccountMappingsOptionsInternal>(options);

			var funcResult = EOS_Connect_GetExternalAccountMapping(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<ProductUserId>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch an external account id, in string form, that maps to a given product user id
		/// </summary>
		/// <param name="options">structure containing the local user and target product user id</param>
		/// <param name="outBuffer">The buffer into which the account id data should be written. The buffer must be long enough to hold a string of <see cref="ExternalAccountIdMaxLength" />.</param>
		/// <param name="inOutBufferLength">
		/// The size of the OutBuffer in characters.
		/// The input buffer should include enough space to be null-terminated.
		/// When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
		/// </param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account id was copied into the OutBuffer
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the mapping doesn't exist or hasn't been queried yet
		/// <see cref="Result.LimitExceeded" /> - The OutBuffer is not large enough to receive the external account id. InOutBufferLength contains the required minimum length to perform the operation successfully.
		/// </returns>
		public Result GetProductUserIdMapping(GetProductUserIdMappingOptions options, System.Text.StringBuilder outBuffer, ref int inOutBufferLength)
		{
			var optionsInternal = Helper.CopyProperties<GetProductUserIdMappingOptionsInternal>(options);

			var funcResult = EOS_Connect_GetProductUserIdMapping(InnerHandle, ref optionsInternal, outBuffer, ref inOutBufferLength);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch the number of linked external accounts for a product user id.
		/// <seealso cref="CopyProductUserExternalAccountByIndex" />
		/// <seealso cref="Achievements" />
		/// </summary>
		/// <param name="options">The Options associated with retrieving the external account info count.</param>
		/// <returns>
		/// Number of external accounts or 0 otherwise
		/// </returns>
		public uint GetProductUserExternalAccountCount(GetProductUserExternalAccountCountOptions options)
		{
			var optionsInternal = Helper.CopyProperties<GetProductUserExternalAccountCountOptionsInternal>(options);

			var funcResult = EOS_Connect_GetProductUserExternalAccountCount(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<uint>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch information about an external account linked to a product user id.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// <seealso cref="Achievements" />
		/// </summary>
		/// <param name="options">Structure containing the target index.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given index.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet
		/// </returns>
		public Result CopyProductUserExternalAccountByIndex(CopyProductUserExternalAccountByIndexOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsInternal = Helper.CopyProperties<CopyProductUserExternalAccountByIndexOptionsInternal>(options);

			outExternalAccountInfo = Helper.GetDefault<ExternalAccountInfo>();

			var outExternalAccountInfoAddress = IntPtr.Zero;

			var funcResult = EOS_Connect_CopyProductUserExternalAccountByIndex(InnerHandle, ref optionsInternal, ref outExternalAccountInfoAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch information about an external account of a specific type linked to a product user id.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// <seealso cref="Achievements" />
		/// </summary>
		/// <param name="options">Structure containing the target external account type.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given external account type.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet
		/// </returns>
		public Result CopyProductUserExternalAccountByAccountType(CopyProductUserExternalAccountByAccountTypeOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsInternal = Helper.CopyProperties<CopyProductUserExternalAccountByAccountTypeOptionsInternal>(options);

			outExternalAccountInfo = Helper.GetDefault<ExternalAccountInfo>();

			var outExternalAccountInfoAddress = IntPtr.Zero;

			var funcResult = EOS_Connect_CopyProductUserExternalAccountByAccountType(InnerHandle, ref optionsInternal, ref outExternalAccountInfoAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch information about an external account linked to a product user id.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// <seealso cref="Achievements" />
		/// </summary>
		/// <param name="options">Structure containing the target external account id.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given external account id.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet
		/// </returns>
		public Result CopyProductUserExternalAccountByAccountId(CopyProductUserExternalAccountByAccountIdOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsInternal = Helper.CopyProperties<CopyProductUserExternalAccountByAccountIdOptionsInternal>(options);

			outExternalAccountInfo = Helper.GetDefault<ExternalAccountInfo>();

			var outExternalAccountInfoAddress = IntPtr.Zero;

			var funcResult = EOS_Connect_CopyProductUserExternalAccountByAccountId(InnerHandle, ref optionsInternal, ref outExternalAccountInfoAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch information about a Product User, using the external account that they most recently logged in with as the reference.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// <seealso cref="Achievements" />
		/// </summary>
		/// <param name="options">Structure containing the target external account id.</param>
		/// <param name="outExternalAccountInfo">The external account info data last logged in for the user.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet
		/// </returns>
		public Result CopyProductUserInfo(CopyProductUserInfoOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsInternal = Helper.CopyProperties<CopyProductUserInfoOptionsInternal>(options);

			outExternalAccountInfo = Helper.GetDefault<ExternalAccountInfo>();

			var outExternalAccountInfoAddress = IntPtr.Zero;

			var funcResult = EOS_Connect_CopyProductUserInfo(InnerHandle, ref optionsInternal, ref outExternalAccountInfoAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch the number of product users that are logged in.
		/// </summary>
		/// <returns>
		/// the number of product users logged in.
		/// </returns>
		public int GetLoggedInUsersCount()
		{
			var funcResult = EOS_Connect_GetLoggedInUsersCount(InnerHandle);
			var funcResultReturn = Helper.GetDefault<int>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch a product user id that is logged in. This product user id is in the Epic Online Services namespace
		/// </summary>
		/// <param name="index">an index into the list of logged in users. If the index is out of bounds, the returned product user id will be invalid.</param>
		/// <returns>
		/// the product user id associated with the index passed
		/// </returns>
		public ProductUserId GetLoggedInUserByIndex(int index)
		{
			var funcResult = EOS_Connect_GetLoggedInUserByIndex(InnerHandle, index);
			var funcResultReturn = Helper.GetDefault<ProductUserId>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetches the login status for an product user id. This product user id is considered logged in as long as the underlying access token has not expired.
		/// </summary>
		/// <param name="localUserId">the product user id of the user being queried</param>
		/// <returns>
		/// the enum value of a user's login status
		/// </returns>
		public LoginStatus GetLoginStatus(ProductUserId localUserId)
		{
			var funcResult = EOS_Connect_GetLoginStatus(InnerHandle, localUserId.InnerHandle);
			var funcResultReturn = Helper.GetDefault<LoginStatus>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Register to receive upcoming authentication expiration notifications.
		/// Notification is approximately 10 minutes prior to expiration.
		/// Call <see cref="Login" /> again with valid third party credentials to refresh access
		/// 
		/// @note must call RemoveNotifyAuthExpiration to remove the notification
		/// </summary>
		/// <param name="options">structure containing the API version of the callback to use</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the callback</param>
		/// <param name="notification">a callback that is fired when the authentication is about to expire</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyAuthExpiration(AddNotifyAuthExpirationOptions options, object clientData, OnAuthExpirationCallback notification)
		{
			var optionsInternal = Helper.CopyProperties<AddNotifyAuthExpirationOptionsInternal>(options);

			var notificationInternal = new OnAuthExpirationCallbackInternal(OnAuthExpiration);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, notification, notificationInternal);

			var funcResult = EOS_Connect_AddNotifyAuthExpiration(InnerHandle, ref optionsInternal, clientDataAddress, notificationInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			var funcResultReturn = Helper.GetDefault<ulong>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Unregister from receiving expiration notifications.
		/// </summary>
		/// <param name="inId">handle representing the registered callback</param>
		public void RemoveNotifyAuthExpiration(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);
			EOS_Connect_RemoveNotifyAuthExpiration(InnerHandle, inId);
		}

		/// <summary>
		/// Register to receive user login status updates.
		/// @note must call RemoveNotifyLoginStatusChanged to remove the notification
		/// </summary>
		/// <param name="options">structure containing the API version of the callback to use</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the callback</param>
		/// <param name="notification">a callback that is fired when the login status for a user changes</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLoginStatusChanged(AddNotifyLoginStatusChangedOptions options, object clientData, OnLoginStatusChangedCallback notification)
		{
			var optionsInternal = Helper.CopyProperties<AddNotifyLoginStatusChangedOptionsInternal>(options);

			var notificationInternal = new OnLoginStatusChangedCallbackInternal(OnLoginStatusChanged);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, notification, notificationInternal);

			var funcResult = EOS_Connect_AddNotifyLoginStatusChanged(InnerHandle, ref optionsInternal, clientDataAddress, notificationInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			var funcResultReturn = Helper.GetDefault<ulong>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Unregister from receiving user login status updates.
		/// </summary>
		/// <param name="inId">handle representing the registered callback</param>
		public void RemoveNotifyLoginStatusChanged(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);
			EOS_Connect_RemoveNotifyLoginStatusChanged(InnerHandle, inId);
		}

		[MonoPInvokeCallback]
		internal static void OnLoginStatusChanged(IntPtr address)
		{
			OnLoginStatusChangedCallback callback = null;
			LoginStatusChangedCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnLoginStatusChangedCallback, LoginStatusChangedCallbackInfoInternal, LoginStatusChangedCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnAuthExpiration(IntPtr address)
		{
			OnAuthExpirationCallback callback = null;
			AuthExpirationCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnAuthExpirationCallback, AuthExpirationCallbackInfoInternal, AuthExpirationCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnQueryProductUserIdMappings(IntPtr address)
		{
			OnQueryProductUserIdMappingsCallback callback = null;
			QueryProductUserIdMappingsCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnQueryProductUserIdMappingsCallback, QueryProductUserIdMappingsCallbackInfoInternal, QueryProductUserIdMappingsCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnQueryExternalAccountMappings(IntPtr address)
		{
			OnQueryExternalAccountMappingsCallback callback = null;
			QueryExternalAccountMappingsCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnQueryExternalAccountMappingsCallback, QueryExternalAccountMappingsCallbackInfoInternal, QueryExternalAccountMappingsCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnDeleteDeviceId(IntPtr address)
		{
			OnDeleteDeviceIdCallback callback = null;
			DeleteDeviceIdCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnDeleteDeviceIdCallback, DeleteDeviceIdCallbackInfoInternal, DeleteDeviceIdCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnCreateDeviceId(IntPtr address)
		{
			OnCreateDeviceIdCallback callback = null;
			CreateDeviceIdCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnCreateDeviceIdCallback, CreateDeviceIdCallbackInfoInternal, CreateDeviceIdCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnLinkAccount(IntPtr address)
		{
			OnLinkAccountCallback callback = null;
			LinkAccountCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnLinkAccountCallback, LinkAccountCallbackInfoInternal, LinkAccountCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnCreateUser(IntPtr address)
		{
			OnCreateUserCallback callback = null;
			CreateUserCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnCreateUserCallback, CreateUserCallbackInfoInternal, CreateUserCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnLogin(IntPtr address)
		{
			OnLoginCallback callback = null;
			LoginCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnLoginCallback, LoginCallbackInfoInternal, LoginCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_ExternalAccountInfo_Release(IntPtr externalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_RemoveNotifyLoginStatusChanged(IntPtr handle, ulong inId);

		[DllImport(Config.BinaryName)]
		private static extern ulong EOS_Connect_AddNotifyLoginStatusChanged(IntPtr handle, ref AddNotifyLoginStatusChangedOptionsInternal options, IntPtr clientData, OnLoginStatusChangedCallbackInternal notification);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_RemoveNotifyAuthExpiration(IntPtr handle, ulong inId);

		[DllImport(Config.BinaryName)]
		private static extern ulong EOS_Connect_AddNotifyAuthExpiration(IntPtr handle, ref AddNotifyAuthExpirationOptionsInternal options, IntPtr clientData, OnAuthExpirationCallbackInternal notification);

		[DllImport(Config.BinaryName)]
		private static extern LoginStatus EOS_Connect_GetLoginStatus(IntPtr handle, IntPtr localUserId);

		[DllImport(Config.BinaryName)]
		private static extern IntPtr EOS_Connect_GetLoggedInUserByIndex(IntPtr handle, int index);

		[DllImport(Config.BinaryName)]
		private static extern int EOS_Connect_GetLoggedInUsersCount(IntPtr handle);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_CopyProductUserInfo(IntPtr handle, ref CopyProductUserInfoOptionsInternal options, ref IntPtr outExternalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_CopyProductUserExternalAccountByAccountId(IntPtr handle, ref CopyProductUserExternalAccountByAccountIdOptionsInternal options, ref IntPtr outExternalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_CopyProductUserExternalAccountByAccountType(IntPtr handle, ref CopyProductUserExternalAccountByAccountTypeOptionsInternal options, ref IntPtr outExternalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_CopyProductUserExternalAccountByIndex(IntPtr handle, ref CopyProductUserExternalAccountByIndexOptionsInternal options, ref IntPtr outExternalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern uint EOS_Connect_GetProductUserExternalAccountCount(IntPtr handle, ref GetProductUserExternalAccountCountOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_GetProductUserIdMapping(IntPtr handle, ref GetProductUserIdMappingOptionsInternal options, System.Text.StringBuilder outBuffer, ref int inOutBufferLength);

		[DllImport(Config.BinaryName)]
		private static extern IntPtr EOS_Connect_GetExternalAccountMapping(IntPtr handle, ref GetExternalAccountMappingsOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_QueryProductUserIdMappings(IntPtr handle, ref QueryProductUserIdMappingsOptionsInternal options, IntPtr clientData, OnQueryProductUserIdMappingsCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_QueryExternalAccountMappings(IntPtr handle, ref QueryExternalAccountMappingsOptionsInternal options, IntPtr clientData, OnQueryExternalAccountMappingsCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_DeleteDeviceId(IntPtr handle, ref DeleteDeviceIdOptionsInternal options, IntPtr clientData, OnDeleteDeviceIdCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_CreateDeviceId(IntPtr handle, ref CreateDeviceIdOptionsInternal options, IntPtr clientData, OnCreateDeviceIdCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_LinkAccount(IntPtr handle, ref LinkAccountOptionsInternal options, IntPtr clientData, OnLinkAccountCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_CreateUser(IntPtr handle, ref CreateUserOptionsInternal options, IntPtr clientData, OnCreateUserCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_Login(IntPtr handle, ref LoginOptionsInternal options, IntPtr clientData, OnLoginCallbackInternal completionDelegate);
	}
}